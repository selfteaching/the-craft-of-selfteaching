# 摘抄：（道理模块）
## 前言
One has no future if one couldn't teach themself
> - 至少有 99% 的人终生都没有掌握自学能力
> - 应试教育的确是磨灭自学能力的最有效方法
> - 焦虑不是被卖方贩卖的产品，焦虑其实是买方长期自行积累的结果。别人无法贩卖给你焦虑，是你自己焦虑 —— 是你自己在为自己不断积累越来越多的焦虑。**但自学能力强的人不焦虑，起码他们不会因为学习以及学习过程而焦虑 —— 这是重大差别。**
> - 生活质量就是这样一点一点被消磨掉的 —— 最消耗生活质量的东西，就是焦虑。
> - 讲大道理的更可能是庸者、失败者，而不是成功者。
> - 不仅讨厌老生常谈，而且偏要对着干，干着干着就把自己变成了另外一个属于那 99% 的另外一个老生……这是 99% 的人终其一生的生动写照。
> - 在自学这件事上，重视一切老生常谈……
> - 自学没有什么 “秘诀”。它是一门手艺，并且，严格意义上来讲，它只是一门手艺。
> - 手艺的特点就是无需天分。手艺的特点就是熟练程度决定一切。从这一点上来看，自学这门手艺和擀饺子皮没什么区别 —— 就那点事，刚开始谁都笨手笨脚，但熟练了之后，就那么回事…… 而已。（**全书精华**）
## 如何证明你真的读过这本书？
更朴素一点，更接近真相的解释是：
> - 那百分之七八十的人，其实是想着给自己一个希望……
—— 等我有空了一定看。嗯。
说来好笑，其实每个人共同拥有的目标之一是这样的：
 成为前百分之二十的少数人……
然而，PK 掉百分之七八十的人的方法真的很简单很简单啊：
 把买来的书都真真切切地认真读过就可以了。
这实在是太简单了罢？！可是…… 我知道你刚刚那个没出息的闪念：
 那我少买书甚至不买书不就可以了吗？
你自己都知道这是荒谬的，却忍不住为你的小聪明得意 —— 其实吧，幸亏有你们在，否则我们怎么混进前百分之二十呢？
**太真实了······**
> - 比特币这个地球上第一个真正被证明为可行的区块链应用中有一个特别重要的概念，叫做 “工作证明”（Proof of Work）—— 你干活了就是干活了，你没干活就是没干活，你的工作是可被证明的……
证明的方法是使用 github.com 这个网站以及版本控制工具 git。（**本来这篇笔记是写在石墨文档上的，因为重复阅读、总结梳理的时候看到这里，竟然发现之前看的那一遍竟然没注意到这个细节，甚至之前好多细节都没注意到，所以反复阅读，重复阅读，及时总结梳理是多么的重要啊！**）
编程入门的门槛之所以高，有个比较特殊的原因：它的知识点结构不是线性的。
- 前置引用：想要理解当前的知识点，需要依赖对以后才能开始学习的知识点的深入理解。
- 学编程中最重要的活动就是 “阅读官方文档”。学 Python 更是如此。
- 有能力只靠阅读就能习得新技能。
- 自己生活工作学习上遇到的所有疑问，书本里应该都有答案 —— 起码有所参考。
- 绝大多数情况下，没人能教你，也不一定有人愿意教你…… 到最后，你想学会或你必须学会什么东西的时候，你只能靠阅读！ —— 因为其实你谁都靠不上……
## 1.A为什么一定要掌握自学能力？
只有一样东西真正可靠——**自学能力**
> -
## 1.B为什么把编程作为自学的入口？
你身边总有些人能把别人做不好的事做得极好，因为他们的自学能力强
> -
## 1.C只靠阅读习得新技能
我们希望看到**通俗易懂、逻辑严谨**的非虚构类好作品，所以自己写东西也要力求达到这一点，决不要**故弄玄虚、偷梁换柱**。
> -刚开始的时候可能需要有人陪伴，一起学，一起讨论，一起克服困难…… 但就是要摆脱 “没人教，没人带，没人逼，就彻底没戏” 的状态。
> -
## 1.D阅读前的一些准备
> -1.以布尔值为入口开始理解程序本质
> -2.了解值的分类和运算方法
> -3.简要了解流程控制的原理
> -4.简要了解函数的基本构成
> -5.相对完整地了解字符串的操作
> -6.了解各种容器的基础操作
> -7.简要了解文件的读写操作

## 1.E.1入口
**逻辑操作符**Logic Operators
> -==  等于
> -!=  不等于
> ->   大于
> ->=  大于等于
> -<   小于
> -<=  小于等于
> -in  属于
执行页面中程序的方法:选中程序块，按shift+Enter
赋值 Assignment
变量 Variable
常量 Literal
函数 Functions
> -函数名 Function Name
> -参数   Parameters
> -返回值 Return Value
> -调用   Call

## 1.E.2值与其相应的运算
> -运算 Evaluation
> -流程控制 Contrl Flow
if……和for……条件语句可以并列使用
literal的意思是字面的
运算的一个默认法则就是，通常情况下应该是*相同类型的值才能相互运算*。
> -Type Casting(类型转换)

运算优先级从高到低：
操作符
> -数值运算符 高于 逻辑操作符 高于 布尔值操作符

数值
> -幂
> -自加、自减
> -乘除商余
> -加减

逻辑操作符

布尔值
> -非 与 或，not and or

## 1.E.3流程控制
> -1.`for` 语句块还可以附加一个 `else` —— 这是 Python 的一个比较有个性的地方。附加在 `for`结 > -尾的 `else` 语句块，_在没有 `break` 发生的情况下会运行_。
> -2.写嵌套的判断语句或循环语句的时候，最常用 `pass`，因为写嵌套挺费脑子的，一不小心就弄乱了。 > -所以，经常需要先用 `pass` 占位，而后逐一突破。
绝大多数编程语言都提供两种循环结构：
>-Collection-controlled loops(以集合为基础的循环) for……in循环
>-Condition-controlled loops(以条件为基础的循环) while循环

## 1.E.4函数
了解一个函数，无非是要了解它的两个方面：

> * 它的**输入**是怎么构成的（都有哪些参数？如何指定？）；
> * 以及它的**输出**是什么（返回值究竟是什么？）……

在 Python 中，函数的参数，有两种：
> * **位置参数**（Positional Arguments，在官方文档里常被缩写为 *arg*）
> * **关键字参数**（Keyword Arguments，在官方文档里常被缩写为 *kwarg*）
在函数定义中，带有 `=` 的，即，已为其设定了默认值的参数，叫做 Keyword Arguments，其它的是 Positional Arguments。

在调用有 Keyword Arguments 的函数之时，如若不提供这些参数，那么参数在执行时，启用的是它在定义的时候为那些 Keyword Arguments 所设定的默认值；如若提供了这些参数的值，那么参数在执行的时候，启用的是接收到的相应值。

本章需要了解的地方

> * 你可以把函数当作一个产品，而你自己是这个产品的用户；
> * 既然你是产品的用户，你要养成好习惯，一定要亲自阅读产品说明书；
> * 调用函数的时候，注意*可选位置参数的使用方法*和*关键字参数的默认值*；
> * 函数定义部分，注意两个符号就行了，`[]` 和 `=`；
> * 所有的函数都有返回值，即便它内部不指定返回值，也有一个默认返回值：`None`；
> * 另外，一定要耐心阅读该函数在使用的时候需要注意什么 —— 产品说明书的主要作用就在这里……

## 1.E.5字符串
字符串属于有序容器
> -例：
> -s='Python'
> -for char in s:
> -    print(s.index(char),char)
s[start:stop:step]返回从索引值为start到stop的那个字符之前的，以step为步长的所有字符
包含左侧的start，不含右边的stop。


###处理字符串的内建函数
写在类的内部了函数，有个专门的名称，类的方法***Method***.
ord()
input()
int()
float()
len()
print()
chr() 这是与ord()相对的函数，即把Unicode码转为字符

调用str类的Methods是使用`.`这个符号，'Python'.upper()
> -str.upper()     
> -str.lower()
> -str.capitallize()  句首字母大写
> -str.title()        每个单词首字母大写
> -str.swapcase()     逐个字符更替大小写  
> -str.casefold()     转换成小写，能处理更多欧洲语言字符
> -str.capitalize()   专门针对行首字母大写的方法
> -str.title()        针对每个词首字母大写的方法
> -str.encode()       处理非英文字符串时经常会用到

***在Python命令行工具之中，单个下刬线是个特殊的变量，保存着最近的语句或者表达式的结果***

###搜索与替换
str.count(sub[,start=0[,stop=len(str)]])
给sub一个参数的话，默认从第一个字符搜索到字符串结束，返回值为字符串中sub出现的次数
没有找到就返回 -1.

str.find(sub[,start[,stop]])   返回最早sub出现的那次位置
str.rfind(sub[,start[,stop]])  返回最后sub出现的那次位置
str.index(sub[,start[,stop]])  作用与find（）相同，但如果没找到，会触发ValueError异常
str.rindex(sub[,start[,stop]]) 作用与rfind（）相同，但如果没找到，会触发ValueError异常

判断一个字符串是否以某个子字符串起始或者结束的：
str.startswith(prefix[,start[,stop]])
str.endswith(suffix[,start[,stop]])

替换：
str.replace(old,new[,count])
用new替换old，替换count个实例

专门替换TAB(\t)的Method
str.expandtabs(tabsize=8)
将TAB替换成空格，默认是8个空格，也可自己指定

去除子字符
str.strip([chars])
去除一个字符串首尾的所有空白，但如果给定了一个字符串作为参数，那么参数字符串中的所有
字母都会被当做需要从首尾剔除的对象，直到新的首尾字母不包含在参数中，就会停止剔除。
str.lstrip()只对左侧处理
str.rstrip()只对右侧处理

###拆分字符串

str.splitlines() 按行拆分，返回一个列表，被拆分的每一行作为其中的元素
str.split()将一个字符串根据分隔符拆分
> -str.split(sep=None,maxsplit=-1)  默认用各种空白分割，maxsplit是拆分次数，
> -默认-1指全部拆分

###拼接字符串

str.join(_iterable_)

###字符串排版

str.center(width[,fillchar]),第二个参数可选，且只接收单个字符
将字符串靠左或者靠右对齐放置：
> -str.ljust(width[,fillchar])
> -str.rjust(width[,fillchar])

将字符串转换为左侧由0填充的指定长度字符串str.zfill(length)

###格式化字符串

str.format()

f-string

###字符串属性


## 1.E.6 数据容器

有序类型：字符串、range()生成的等差数列、元组
无序类型：集合与字典

可变的：列表、集合、字典、Set
不可变：字符串、range()生成的、元组、Frozen Set

可迭代的（Iterable）容器中的元素可以被逐个访问，以便被处理。  in 操作符

生成一个列表：list()  list(iterable)
